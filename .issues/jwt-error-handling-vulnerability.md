---
apps:
  - mcp-proxy
severity: low
difficulty: low
---

# JWT エラー処理の脆弱性

## 概要

JWTエラーの判定がエラーメッセージ文字列検索に依存しており、ライブラリのバージョンアップで動作が変わるリスク。

## 重大度

低

## 影響範囲

- `apps/mcp-proxy/src/middleware/auth/jwt.ts`
- `apps/mcp-proxy/src/middleware/auth/index.ts`

## 詳細

### 現状

`jwt.ts:55-69` および `index.ts:185-199` で、エラーメッセージの文字列検索によりエラーの種類を判定:

```typescript
try {
  jwtPayload = await verifyKeycloakJWT(accessToken);
} catch (error) {
  const errorMessage = (error as Error).message;

  // エラーメッセージから原因を判定
  if (errorMessage.includes("expired")) {
    return c.json(createUnauthorizedError("Token has expired"), 401);
  }

  if (errorMessage.includes("signature")) {
    return c.json(createUnauthorizedError("Invalid token signature"), 401);
  }

  logError("JWT verification failed", error as Error);
  return c.json(createUnauthorizedError("Invalid access token"), 401);
}
```

### 問題点

1. **ライブラリ依存のエラーメッセージ**
   - `jose` ライブラリのエラーメッセージに依存
   - ライブラリのバージョンアップでメッセージが変更される可能性
   - 国際化やローカライズでメッセージが変わる可能性

2. **エラータイプの未使用**
   - `jose` ライブラリは型付きエラー（`JWTExpired`, `JWTInvalid` など）を提供
   - 文字列検索より型チェックの方が堅牢

3. **部分一致の問題**
   - "expired" という文字列が他の文脈で使われる可能性
   - 誤検出のリスク

4. **テスト困難**
   - 文字列検索ロジックのテストが困難
   - エラーメッセージの変更に追従する必要

### 影響

- **信頼性**: ライブラリ更新後に予期しない動作が発生する可能性
- **保守性**: エラー処理の変更が困難
- **セキュリティ**: エラーの誤分類により不適切なレスポンスを返す可能性

## 推奨される対策

1. **型付きエラーの使用**

```typescript
import { errors } from "jose";

try {
  jwtPayload = await verifyKeycloakJWT(accessToken);
} catch (error) {
  if (error instanceof errors.JWTExpired) {
    return c.json(createUnauthorizedError("Token has expired"), 401);
  }

  if (error instanceof errors.JWTClaimValidationFailed) {
    logError("JWT claim validation failed", error);
    return c.json(createUnauthorizedError("Invalid token claims"), 401);
  }

  if (error instanceof errors.JWSSignatureVerificationFailed) {
    return c.json(createUnauthorizedError("Invalid token signature"), 401);
  }

  logError("JWT verification failed", error as Error);
  return c.json(createUnauthorizedError("Invalid access token"), 401);
}
```

2. **エラーハンドリングの集約**

```typescript
// libs/auth/jwt-error.ts
export const handleJwtError = (error: unknown): JwtErrorResult => {
  if (error instanceof errors.JWTExpired) {
    return { type: "expired", message: "Token has expired" };
  }
  // ...
};
```

3. **統一エラーレスポンス**（#001参照）
   - セキュリティ上の理由から、詳細なエラー種別をクライアントに返さない選択肢もある

4. **単体テストの追加**

```typescript
describe("JWT error handling", () => {
  test("JWTExpiredエラーを正しく処理する", async () => {
    const expiredToken = createExpiredToken();
    const response = await request(app)
      .post("/mcp/test-server")
      .set("Authorization", `Bearer ${expiredToken}`);
    expect(response.status).toBe(401);
  });
});
```

## 関連ファイル

- `apps/mcp-proxy/src/middleware/auth/jwt.ts`
- `apps/mcp-proxy/src/middleware/auth/index.ts`
- `apps/mcp-proxy/src/libs/auth/jwt-verifier.ts`
