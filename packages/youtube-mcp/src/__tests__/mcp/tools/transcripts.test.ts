import type { YoutubeApiKey } from "@/api/apiKey.js";
import type { Failure, Success } from "@/lib/result.js";
import type { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { getTranscriptMetadata } from "@/api/transcripts/index.js";
import { err, ok } from "@/lib/result.js";
import { getTranscript } from "@/lib/ytdlp/index.js";
import { YOU_TUBE_TOOL_NAMES } from "@/mcp/constants.js";
import { handleTranscriptTool } from "@/mcp/tools/transcripts.js";
import { beforeEach, describe, expect, test, vi } from "vitest";

// モック化
vi.mock("@/api/transcripts/index.js", () => ({
  getTranscriptMetadata: vi.fn(),
}));

vi.mock("@/lib/ytdlp/index.js", () => ({
  getTranscript: vi.fn(),
}));

const mockGetTranscriptMetadata = vi.mocked(getTranscriptMetadata);
const mockGetTranscript = vi.mocked(getTranscript);
const mockApiKey = "test-api-key" as YoutubeApiKey;

describe("handleTranscriptTool", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe("get_transcript_metadata", () => {
    const mockTranscriptMetadata = [
      {
        language: "ja",
        name: "Japanese",
        isAutoGenerated: false,
      },
      {
        language: "en",
        name: "English",
        isAutoGenerated: true,
      },
    ];

    test("正常系: 字幕メタデータを取得して正しいレスポンスを返す", async () => {
      mockGetTranscriptMetadata.mockResolvedValueOnce(
        ok(mockTranscriptMetadata),
      );

      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT_METADATA,
        { videoId: "test-video-id" },
        mockApiKey,
      );

      expect(result).toStrictEqual({
        success: true,
        data: {
          content: [
            {
              type: "text",
              text: JSON.stringify(mockTranscriptMetadata),
            },
          ],
        },
      } satisfies Success<CallToolResult>);
      expect(mockGetTranscriptMetadata).toHaveBeenCalledWith(
        "test-video-id",
        mockApiKey,
      );
    });

    test("異常系: 不正な引数の場合にエラーを返す", async () => {
      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT_METADATA,
        { invalidParam: "invalid" },
        mockApiKey,
      );

      expect(result).toStrictEqual({
        success: false,
        error: expect.any(Error),
      } satisfies Failure<Error>);
    });

    test("異常系: API呼び出しが失敗した場合にエラーを返す", async () => {
      mockGetTranscriptMetadata.mockResolvedValueOnce(
        err(new Error("Transcript Metadata API Error")),
      );

      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT_METADATA,
        { videoId: "test-video-id" },
        mockApiKey,
      );

      expect(result).toStrictEqual({
        success: false,
        error: new Error("Transcript Metadata API Error"),
      } satisfies Failure<Error>);
    });
  });

  describe("get_transcript", () => {
    const mockTranscriptData = {
      segments: [
        {
          start: 0,
          end: 3,
          duration: 3,
          text: "We're no strangers to love",
        },
        {
          start: 3,
          end: 6,
          duration: 3,
          text: "You know the rules and so do I",
        },
      ],
    };

    test("正常系: 字幕を取得して正しいレスポンスを返す", async () => {
      mockGetTranscript.mockResolvedValueOnce(ok(mockTranscriptData));

      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT,
        { videoId: "test-video-id", language: "en" },
        mockApiKey,
      );

      expect(result).toStrictEqual({
        success: true,
        data: {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                segments: mockTranscriptData.segments,
              }),
            },
          ],
        },
      } satisfies Success<CallToolResult>);
      expect(mockGetTranscript).toHaveBeenCalledWith(
        "test-video-id",
        "en",
        undefined,
        undefined,
      );
    });

    test("正常系: 時間範囲でフィルタして字幕を取得する", async () => {
      const filteredTranscriptData = {
        segments: [
          { start: 3, end: 6, duration: 3, text: "Second segment" },
          { start: 6, end: 9, duration: 3, text: "Third segment" },
        ],
      };
      mockGetTranscript.mockResolvedValueOnce(ok(filteredTranscriptData));

      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT,
        {
          videoId: "test-video-id",
          language: "en",
          startTime: 3,
          endTime: 9,
        },
        mockApiKey,
      );

      expect(result.success).toStrictEqual(true);
      const successResult = result as {
        success: true;
        data: { content: { text?: string }[] };
      };
      const text = successResult.data.content[0]?.text;
      expect(typeof text).toBe("string");
      const responseData = JSON.parse(text!) as unknown as any as {
        segments: { text?: string }[];
      };
      expect(responseData.segments).toHaveLength(2);
      expect(responseData.segments[0]?.text).toBe("Second segment");
      expect(responseData.segments[1]?.text).toBe("Third segment");
      expect(mockGetTranscript).toHaveBeenCalledWith(
        "test-video-id",
        "en",
        3,
        9,
      );
    });

    test("正常系: 開始時間のみを指定して字幕を取得する", async () => {
      const filteredTranscriptData = {
        segments: [
          { start: 3, end: 6, duration: 3, text: "Second segment" },
          { start: 6, end: 9, duration: 3, text: "Third segment" },
        ],
      };
      mockGetTranscript.mockResolvedValueOnce(ok(filteredTranscriptData));

      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT,
        {
          videoId: "test-video-id",
          language: "en",
          startTime: 3,
        },
        mockApiKey,
      );

      expect(result.success).toStrictEqual(true);
      const successResult = result as {
        success: true;
        data: { content: { text?: string }[] };
      };
      const text = successResult.data.content[0]?.text;
      expect(typeof text).toBe("string");
      const responseData = JSON.parse(text!) as unknown as any as {
        segments: { text?: string }[];
      };
      expect(responseData.segments).toHaveLength(2);
      expect(responseData.segments[0]?.text).toBe("Second segment");
      expect(responseData.segments[1]?.text).toBe("Third segment");
      expect(mockGetTranscript).toHaveBeenCalledWith(
        "test-video-id",
        "en",
        3,
        undefined,
      );
    });

    test("正常系: 終了時間のみを指定して字幕を取得する", async () => {
      const filteredTranscriptData = {
        segments: [
          { start: 0, end: 3, duration: 3, text: "First segment" },
          { start: 3, end: 6, duration: 3, text: "Second segment" },
        ],
      };
      mockGetTranscript.mockResolvedValueOnce(ok(filteredTranscriptData));

      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT,
        {
          videoId: "test-video-id",
          language: "en",
          endTime: 6,
        },
        mockApiKey,
      );

      expect(result.success).toStrictEqual(true);
      const successResult = result as {
        success: true;
        data: { content: { text?: string }[] };
      };
      const text = successResult.data.content[0]?.text;
      expect(typeof text).toBe("string");
      const responseData = JSON.parse(text!) as unknown as any as {
        segments: { text?: string }[];
      };
      expect(responseData.segments).toHaveLength(2);
      expect(responseData.segments[0]?.text).toBe("First segment");
      expect(responseData.segments[1]?.text).toBe("Second segment");
      expect(mockGetTranscript).toHaveBeenCalledWith(
        "test-video-id",
        "en",
        undefined,
        6,
      );
    });

    test("異常系: 不正な引数の場合にエラーを返す", async () => {
      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT,
        { invalidParam: "invalid" },
        mockApiKey,
      );

      expect(result).toStrictEqual({
        success: false,
        error: expect.any(Error),
      } satisfies Failure<Error>);
    });

    test("異常系: yt-dlp関数が失敗した場合にエラーを返す", async () => {
      mockGetTranscript.mockResolvedValueOnce(err(new Error("yt-dlp error")));

      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT,
        { videoId: "test-video-id", language: "en" },
        mockApiKey,
      );

      expect(result).toStrictEqual({
        success: false,
        error: new Error("yt-dlp error"),
      } satisfies Failure<Error>);
    });
  });

  describe("unknown tool", () => {
    test("異常系: 不明なツール名の場合にエラーを返す", async () => {
      const result = await handleTranscriptTool("unknown_tool", {}, mockApiKey);

      expect(result).toStrictEqual({
        success: false,
        error: new Error("Unknown tool: unknown_tool"),
      } satisfies Failure<Error>);
    });
  });

  describe("exception handling", () => {
    test("異常系: 予期しない例外が発生した場合にエラーを返す", async () => {
      mockGetTranscriptMetadata.mockRejectedValueOnce(
        new Error("Unexpected error"),
      );

      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT_METADATA,
        { videoId: "test-video-id" },
        mockApiKey,
      );

      expect(result).toStrictEqual({
        success: false,
        error: new Error("Unexpected error"),
      } satisfies Failure<Error>);
    });

    test("異常系: 非Errorオブジェクトが投げられた場合に文字列化してエラーを返す", async () => {
      mockGetTranscriptMetadata.mockRejectedValueOnce("string error");

      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT_METADATA,
        { videoId: "test-video-id" },
        mockApiKey,
      );

      expect(result).toStrictEqual({
        success: false,
        error: new Error("string error"),
      } satisfies Failure<Error>);
    });
  });
});
