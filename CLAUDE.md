# CLAUDE.md

Claude Code がこのリポジトリで作業する際のガイダンスファイルです。

## Serenaシンボリックツールの使用方法

Serenaのシンボリックツールへのアクセスが提供されています。以下の指示に従って使用してください。

あなたは特定のコードベースに特化したプロフェッショナルなコーディングエージェントです。セマンティックなコーディングツールにアクセスでき、これらのツールに大きく依存して作業を行います。また、コードベースに関する一般的な情報を含むメモリファイルのコレクションも利用できます。リソース効率的で賢明な方法で動作し、手元のタスクに必要のないコンテンツの読み込みや生成を避けることを常に心がけてください。

### 重要な原則

**ファイル全体を不必要に読み込まないでください！**

ユーザーの質問やタスクに答えるためにコードを読む際は、必要なコードのみを読むように心がけてください。一部のタスクではコードベースの大部分のアーキテクチャを理解する必要がありますが、その他の場合は、シンボルの小さなセットや単一のファイルを読むだけで十分な場合があります。

一般的に、絶対に必要でない限りファイル全体を読み込むことは避け、代わりに段階的な情報取得に依存してください。ただし、すでにファイルを読み込んでいる場合は、（`find_referencing_symbols`ツールを除いて）シンボリックツールでさらに分析することは意味がありません。すでに情報を持っているからです。

**オーバービューツールやシンボリックツールを使用して、必要なコードのみを最初に読むことを検討してください！**

**ファイル全体を読んだ後に同じコンテンツをシンボリックツールで読み続けることは避けてください！**

**シンボリックツールの目的は、同じコンテンツを複数回読むことではなく、読むコードを減らすことです！**

### 効率的なコード読み取り方法

シンボルの概要とそれらの関係を取得するためのシンボリックツールを使用し、質問に答えるかタスクを完了するために必要なシンボルの本体のみを読むことで、賢いコード読み取りを実現できます。

- 必要に応じて`list_dir`、`find_file`、`search_for_pattern`などの標準ツールを使用できます
- ツールで許可されている場合は、`relative_path`パラメータを渡して検索を特定のファイルまたはディレクトリに制限してください
- 一部のツールでは、`relative_path`はファイルパスのみであるため、ツールの説明を適切に読んでください

シンボルの名前や場所が不確実な場合（シンボル名の部分文字列マッチングでは不十分な程度）、`search_for_pattern`ツールを使用できます。これにより、コードベース内のパターンの高速で柔軟な検索が可能になります。この方法で最初にシンボルやファイルの候補を見つけ、その後シンボリックツールに進むことができます。

### シンボルの識別と操作

シンボルは`name_path`と`relative_path`によって識別されます。`name_path`がシンボルにどのようにマッチするかの詳細については、`find_symbol`ツールの説明を参照してください。

- ファイル内のトップレベルシンボルを見つけるには`get_symbols_overview`ツールを使用
- シンボルの名前パスを既に知っている場合は`find_symbol`を使用
- タスクを解決しながらできるだけ少ないコードを読むよう心がけ、編集したいシンボルを見つけた後に本体を読むようにしてください

### 編集アプローチ

コード編集には2つの主要なアプローチがあります：

1. **シンボルベースの編集**: シンボル全体（メソッド、クラス、関数など）を調整する場合に適しています
2. **正規表現ベースの編集**: シンボル内の数行のコードを調整する場合やシンボル全体より小さなチャンクを扱う場合に使用

### メモリファイルの活用

一般的にメモリにアクセスでき、質問に答えるまたはタスクを完了するのに役立つ場合に読むことが有用です。メモリ名と説明を読むことで、現在のタスクに関連するメモリを推測できます。

## プロジェクト概要

プロジェクトの詳細については [README.md](./README.md) を参照してください。

## 開発コマンド

開発に必要なコマンドについては [README.md](./README.md) の「開発コマンド」セクションを参照してください。

### 型チェックコマンド

- **通常の型チェック**: `pnpm typecheck` - 本番環境・CI用の安定した型チェック（tsc使用）
- **高速型チェック**: `pnpm typecheck:dev` - ローカル開発用の高速型チェック（TSGO使用）
  - TSGOは従来のtscより約10倍高速で型チェックを実行
  - 開発時のみ使用推奨（プレビュー版のため）
  - エラーや互換性問題が発生した場合は通常のtypecheckを使用

## Python MCP サーバーのサポート

Tumiki は Python ベースの MCP サーバーをサポートしています：

- **自動インストール**: `pnpm install` 時に `python-mcp-requirements.txt` のパッケージが自動インストール
- **設定方法**: `mcpServers.ts` で `command: "uvx"` と `args: ["package-name"]` を指定
- **環境変数**: Node.js サーバーと同様に `envVars` で指定
- **追加方法**: `python-mcp-requirements.txt` に追記して `pnpm install` を実行

## 開発ガイドライン

### フロントエンド コーディング規約

- **コンポーネント**: 関数コンポーネント + アロー関数、必須の Props 型定義。呼び出す側と同一階層の `_components/` ディレクトリに配置する。共通で利用するコンポーネントは、呼び出し側の一つ上の `_components/` ディレクトリに配置する。
- **関数定義**: 全ての関数はアロー関数で記述する（`const fn = () => {}` 形式）
- **スタイリング**: Tailwind CSS 使用、カスタムスタイルは `styles/globals.css`。className で条件分岐を含む場合は `clsx` を使用する
- **データフェッチング**: tRPC 使用（`trpc.useQuery()`, `trpc.useMutation()`）
- **状態管理**: ローカルは `useState`、グローバルは Jotai
- **型定義**: 共有型は `@tumiki/db` から import
- **型定義方法**: `type` のみ使用（`interface` は使用しない）
- **ID管理**: branded type を使用し、`@apps/manager/src/schema/ids.ts` に定義
- **設計原則**: DRY原則とSOLID原則を遵守
- **プログラミングパラダイム**: 関数型プログラミング（クラスは使用しない）
- **モジュール構成**: `utils/` や `libs/` からのインポートを容易にするため、`index.ts` にエントリーポイントを用意

### テストコーディング規約

- **フレームワーク**: Vitest 使用
- **テスト記法**: `test` 使用（`it` ではない）、日本語でテスト名を記載
- **構造**: 関数ごとに `describe` ブロックを記載、古典派単体テスト
- **アサーション**: `toStrictEqual` 使用（`toEqual` ではない）
- **実行**: `pnpm test`（`vitest run`）、`pnpm test:watch`（`vitest`）でウォッチモード
- **カバレッジ**: `pnpm test:coverage` でカバレッジ測定、実装ロジックのカバレッジ100%を目標

#### データベーステスト環境

データベースを使用するテストの実行には、専用のテスト環境が必要：

- **テスト用DB**: PostgreSQLコンテナ `db-test`（ポート5433）を使用
- **DB起動**: `docker compose -f ./docker/compose.dev.yaml up -d db-test`
- **スキーマ適用**: `cd packages/db && pnpm db:push:test` でテスト用DBにスキーマを適用
- **環境設定**: `.env.test` でテスト用DB接続設定（`postgresql://root:password@localhost:5433/tumiki_test`）
- **テスト環境**: vitest-environment-vprisma でトランザクション分離された独立テスト実行

## 重要なアーキテクチャパターン

### データベーススキーマ構成

Prisma スキーマは複数のファイルに分割（`packages/db/prisma/schema/`）：

- `base.prisma` - コア設定とジェネレーター
- `auth.prisma` - Auth0認証テーブル
- `mcpServer.prisma` - MCP サーバー定義とツール
- `userMcpServer.prisma` - ユーザー固有のサーバー設定
- `organization.prisma` - マルチテナント組織サポート
- `chat.prisma` - チャット/メッセージング機能
- `apiKey.prisma` - APIキー管理
- `waitingList.prisma` - ウェイティングリスト機能

### API アーキテクチャ

- **tRPC ルーター**: `apps/manager/src/server/api/routers/` に配置
  - `mcpServer.ts` - 定義済みMCPサーバーテンプレート管理
  - `userMcpServerConfig.ts` - ユーザー固有のMCPサーバー設定
  - `userMcpServerInstance.ts` - 実行中のMCPサーバーインスタンス管理
  - `post.ts` - 汎用投稿機能
- **MCP プロキシサーバー**: `apps/proxyServer/src/index.ts`
  - `/mcp` - HTTP/Streamable transport エンドポイント
  - `/sse` - SSE transport エンドポイント（後方互換性）
  - `/messages` - SSE メッセージ送信
- **型安全性**: 自動 API 生成によるフルスタック型安全性、@tumiki/db から型 import

### 認証アーキテクチャ

- **プロバイダー**: Auth0 統合認証
- **設定**: `packages/auth/src/config.ts`
- **セッション**: JWT ベース、Auth0セッション管理
- **ウェブフック**: Post-Login Action による動的ユーザー管理

### セキュリティ機能

- 機密データ（API キー、トークン）のフィールドレベル暗号化
- Auth0 統合認証・認可
- ロールベースアクセス制御
- JWT セッション管理
- ウェブフックシークレット検証

### 開発時の重要事項

- **Node.js**: >=22.14.0 必須
- **パッケージマネージャー**: pnpm@10.11.0 以上
- **型チェック**: 全パッケージで TypeScript strict モード
- **コミット前**: 必ず `pnpm check` 実行（CI環境変数エラーは開発時は無視可能）
- **型インポート**: Prisma 型は `@tumiki/db` から import（`@prisma/client` ではない）
- **ページ構造**: 英語版 `/` と日本語版 `/jp` の2つのランディングページが存在
- **環境変数**: プロジェクト直下の `.env` ファイルに定義。環境変数を読み込んで実行する必要があるものは、
  `dotenv` パッケージを使用して読み込む。ただし、npm scripts 実行時は自動的に読み込まれるため、手動での読み込みは不要。
- **ローカル開発URL**: `https://local.tumiki.cloud:3000` でアクセス。
- **@tumiki/ パッケージのimportエラー**: `@tumiki/` で始まるパッケージのimportに失敗する場合は、該当パッケージのビルドが必要。
  例: `@tumiki/db` のimportエラーが発生した場合 → `cd packages/db && pnpm build` を実行

### CI/CD

- **GitHub Actions**: `.github/workflows/ci.yml`
- **品質チェック**: `pnpm check` で lint + format + typecheck

### 重要な実装パターン

- **フィールド暗号化**: 機密データ（APIキー等）はPrismaの暗号化機能で保護
- **SSE通信**: リアルタイムMCP通信にServer-Sent Eventsを使用
- **セッション管理**: MCPサーバーとの永続的な接続をセッションで管理
- **エラーハンドリング**: tRPCによる型安全なエラー処理とユーザー向けメッセージ
- **データ圧縮**: MCPリクエストデータの圧縮によるパフォーマンス最適化
- **リクエストログ**: ProxyServerでのMCPリクエスト監視・分析
- **PM2管理**: 本番環境でのプロセス管理と自動復旧
- **メトリクス収集**: リアルタイムパフォーマンス監視

## 実装後の必須アクション

**重要**: 実装が完了したら、必ず以下のコマンドを実行してください：

1. **`pnpm format:fix`** - コードフォーマットの自動修正（必須）
2. `pnpm lint:fix` - リントエラーの自動修正
3. `pnpm typecheck` - 型チェック
4. `pnpm build` - ビルド確認
5. `pnpm test` - テスト実行

これらのコマンドは実装完了後に必ず実行し、全てが成功することを確認してください。

## CI/CD - Claude Code Review

### 自動コードレビュー機能

プルリクエストに対してClaude Code Reviewが自動実行されます：

#### レビュー内容

**2段階レビュープロセス**:

1. **第1段階 - 詳細分析**:
   - コード品質とベストプラクティス
   - 設計原則（SOLID、DRY、KISS、YAGNI）の遵守
   - 潜在的なバグとエラーハンドリング
   - パフォーマンスとスケーラビリティ
   - セキュリティリスク評価
   - テストカバレッジ

2. **第2段階 - 優先順位付け**:
   - 重要度スコア（1-10）での評価
   - 具体的な改善コード例の提示
   - 実装すべきアクションの明確化

### 🔧 自動修正ループ機能

Claude Code Reviewの指摘事項を自動的に修正する機能が利用可能です：

#### トリガー方法

以下のいずれかの方法で自動修正ループを起動できます：

1. **ラベルによるトリガー**:
   - `auto-fix` または `claude-auto-fix` ラベルをPRに追加

2. **PRタイトルによるトリガー**:
   - PRタイトルに `[AUTO-FIX]` または `[CLAUDE-FIX]` を含める

3. **手動実行**:
   - GitHub Actions の "Claude Auto-Fix Loop" ワークフローを手動で実行
   - PR番号とドライランモードの指定が可能

#### 動作プロセス

1. Claude Code Reviewを実行して問題を検出
2. 重要度7以上の問題を自動修正対象として選択
3. Claude APIを使用してコードを自動修正
4. 修正内容をコミット＆プッシュ
5. 再度レビューを実行（最大5回まで繰り返し）

#### 設定可能なパラメータ

- **MAX_LOOP_COUNT**: 最大ループ回数（デフォルト: 5）
- **AUTO_FIX_THRESHOLD**: 自動修正対象の重要度閾値（デフォルト: 7）
- **DRY_RUN**: ドライランモード（修正内容の確認のみ）

#### 安全性機能

- **バックアップ機能**: 修正前のコードを自動バックアップ
- **検証機能**: 修正後に型チェック・構文チェックを実行
- **ロールバック機能**: エラー時に自動でロールバック
- **トランザクション処理**: 全修正が成功した場合のみコミット
- **進捗レポート**: 各ループの結果をPRコメントで通知

#### 実行結果の確認

- PRコメントに進捗状況と結果サマリーが投稿されます
- GitHub Actions のサマリーページで詳細レポートを確認できます
- `.github/auto-fix-reports/` ディレクトリに詳細ログが保存されます

## 完了条件

- `pnpm format:fix`, `pnpm lint:fix`, `pnpm typecheck`, `pnpm build`, `pnpm test` が全て成功すること
- Vitest を使って実装ロジックのカバレッジを100%にすること
- 関連ドキュメントの更新完了させること
- PM2での本番環境デプロイが正常に動作すること
- MCPサーバーの統合テストが成功すること
- Claude Code Reviewによる自動レビューで重要度8以上の指摘が解決されていること
